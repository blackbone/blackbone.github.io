---
layout: doc
title: SG фабрика.
date: 2024-04-07 03:00:00
tags:
  - dotnet
  - sourcegenerators
prev:
  text: 'Как определить что SG в юнити.'
  link: '/posts/source_generators/2'
next:
  text: 'SG фабрика.'
  link: '/posts/source_generators/4'
---
# {{ $frontmatter.title }}

Фабрики - довольно распространенная тема, когда нужно использовать полимофризм в совокупности с сериализацией будь то сеть или просто сейвы на диск.

> Описанный ниже подход будет работать исключительно в unity и не требовать от юзера практически никаких лишних движений, в чистом дотнете он работать не будет.

Проблема:

Представим что у нас есть абстрактный класс A и его наследники А1, А2, А3 и т.д. и мы хотим оперировать наследниками как инстансами базы, при этом инстанциировать на основе каких-то мета-данных однозначно представляющих какой именно тип инстанса нам нужен, например:

IFruit apple = Factory<IFruit>.Create("apple");

или так:

IFruit orange = Factory<IFruit>.Create(Fruit.Orange);

или даже так:

IFruit cherry = Factory.Create(Cherry.ID);

Главный юз кейс - создание компонентов из какого-то предзаготовленного конфига в процессе формирования сущностей (детальнее в отдельной статье).
Ограничения:

Главное ограничение - это то, что реализации типов используемых в фабрике могут распологаться в разных сборках, при этом необходимо корректно их создавать из любого места где доступна фабрика и базовый тип.

Если мы представим что наша фабрика находится в сборке Factory.dll, базовый тип IFruit находится в сборке Fruits.Base.dll, а все реализации находятся в других сборках, таких как Fruits.Common.dll, Fruits.Exotic.dll и тд. При этом пользовательский код находится в сборке UserCode.dll как на рисунке ниже.

Из пользовательского кода мы хотим создавать инстансы вишен и всяких апельсинов при этом явно не ссылаясь на сборки, в которых они объявлены, т.к. мы не очень заинтересованы в деталях реализации (чисто например).

Главным вопросом здесь является - где именно мы объявим и зарегистируем фабричные методы (или делегаты) которые непосредственно будут создавать инстансы интересующих нас типов? Ответ простой: там же где они объявлены, такой подход позволит создавать инстансы даже интернал типов не раскрывая детали реализации и не плодя ссылки между сборками.

Псевдокод фабричного метода будет иметь следующий вид:

public static TValue Create<TValue, TKey>(in TKey key)
{
   switch(key) {
      // ... свич чисто для демонстрации того, что тут происходит селект
   } 
}

Исходя из кода выше - свич не прокатит, т.к. с дженериками он работать не будет, да и, как показала практика - на большом количестве элементов он довольно медленный.

Вторым ограничением является регистрация типов - каким-то образом надо явно идентифицировать к какой именно фабрике относится тип-наследник и по какому именно ключу инстанс данного типа будет создаваться. Для этого будем использовать аттрибут (можно обойтись и без аттрибута, но я предпочитаю явно видеть по коду где и что используется). Аттрибут тоже должен быть где-то объявлен и объявлен он будет в сборке Factory.dll, что изменит граф зависимостей следующим образом: